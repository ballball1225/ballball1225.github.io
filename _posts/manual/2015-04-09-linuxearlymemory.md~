---
layout: post
title: Linux内核初始化阶段内存管理的几种阶段
description: 讲述从内核加载到建立完整的内存管理所经历的几种阶段
category: manual
---

本文旨在讲述从引导到完全建立内存管理体系过程中,内核对内存管理所经历的几种状态.





##一些讲在前面的话

在很久很久以前,linux内核还是支持直接从磁盘直接启动,也就是内核镜像自带了一个可以引导的MBR,按照套路计算机上电以后BIOS会将MBR加载到0000:7c00处执行.后来时过境迁,linux内核必须通过grub这些东西来引导了.本文的故事就从grub引导开始....





##内核镜像内存布局
现在计算机上电后BIOS会将grub载入到0000:7c00处执行.grub会根据配置从磁盘将内核载入到内存...过程这里就忽略了,载入完成后内存是这么个分布情况:

![sea](/images/memory/memorylocation.png)


实模式下共20根地址线,能访问到0x100000(1M)的内存.寄存器为16位.地址转换方式为"左移四位加偏移"比如es=0x1000,DI=0xffff,那么es:DI=0x1ffff.实模式下段寄存器存放各段基址,通过段+偏移来寻址. 偏移地址称为有效地址,表示操作数所在单元到段首的距离即逻辑地址的偏移地址. 换算出的地址称为线性地址,在实模式下也为物理地址.(关于虚拟地址,物理地址,线性地址,罗辑地址,请看博客)

那么实模式下能访问的最大物理地址为0xfffff,grub是通过暂时开启保护模式将内核镜像的一部分载入到0x100000的.

由于不同的bootloader由不同大小,x的值(即实模式加载的内存地址也不同),grub将x设为0x9000.grub载入内核大致过程如下:
<ul>
<li>1.       调用一个BIOS过程显示“Loading”信息。</li>
<li>2.       调用一个BIOS过程从磁盘装入内核映像的初始部分，即将内核映像的第一个512字节加载到物理地址0x0009000开始的内存中，而将setup程序的代码（参见后面的内存布局）从地址0x00090200开始存入RAM中。</li>
<li>3.       调用一个BIOS过程从磁盘中装载其余的内核映像，并把内核映像放入从低地址0x00010000（适用于使用make zImage编译的小内核映像）或者从高地址0x00100000（适用于使用make bzImage编译的大内核映像，也就是我们现在的情况）开始的RAM中。大内核映像的支持虽然本质上与其他启动模式相同，但是它却把数据放在不同的物理内存地址，以避免ISA黑洞问题。</li>
<li>4.       跳转到arch/x86/boot/header.S的_start处开始执行。</li>
</ul>





##x个阶段






###准备进入第一次保护模式(内存管理:野蛮)

这个阶段段寄存器保存各个段的基址.

这个时候是grub才将控制权交给内核,汇编代码会简单设置堆栈(ss,esp)和清理bss然后跳入C语言了.进入arch/x86/boot/main.c,调用go_to_protected_mode()进入保护模式(pm.c)

为了进入保护模式,需要先设置gdt,这个时候的gdt为boot_gdt,代码段和数据段描述符中的基址都为0.设置完后就开启保护模式.

	 arch/x86/boot/pm.c    
	 66 static void setup_gdt(void)
	 67 {           
	 68     /* There are machines which are known to not boot with the GDT
	 69        being 8-byte unaligned.  Intel recommends 16 byte alignment. */
	 70     static const u64 boot_gdt[] __attribute__((aligned(16))) = {
	 71         /* CS: code, read/execute, 4 GB, base 0 */
	 72         [GDT_ENTRY_BOOT_CS] = GDT_ENTRY(0xc09b, 0, 0xfffff),
	 73         /* DS: data, read/write, 4 GB, base 0 */
	 74         [GDT_ENTRY_BOOT_DS] = GDT_ENTRY(0xc093, 0, 0xfffff),
	 75         /* TSS: 32-bit tss, 104 bytes, base 4096 */
	 76         /* We only have a TSS here to keep Intel VT happy;
	 77            we don't actually use it for anything. */
	 78         [GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(0x0089, 4096, 103),
	 79     };      
	 80     /* Xen HVM incorrectly stores a pointer to the gdt_ptr, instead
	 81        of the gdt_ptr contents.  Thus, make it static so it will
	 82        stay in memory, at least long enough that we switch to the
	 83        proper kernel GDT. */
	 84     static struct gdt_ptr gdt;
	 85             
	 86     gdt.len = sizeof(boot_gdt)-1;
	 87     gdt.ptr = (u32)&boot_gdt + (ds() << 4);
	 88             
	 89     asm volatile("lgdtl %0" : : "m" (gdt));	//加载段描述符
	 90 } 





###第一次进入保护模式,为了解压内核(内存管理:野蛮)

进入保护模式后,需要一个长跳转,隐式地设置cs:
	1.	movw	$__BOOT_DS, %cx		//数据段选择子
		movw	$__BOOT_TSS, %di	//TTS段选择子

		movl	%cr0, %edx
		orb	$X86_CR0_PE, %dl	# 开启Protected mode 
		movl	%edx, %cr0		//进入保护模式后需要一个长跳转
		# Transition to 32-bit mode
		.byte	0x66, 0xea		# ljmpl opcode	--| ljmpl字节码
	2:	.long	in_pm32			# offset  ---与上条组合成ljmpl in_pm32	  这时候cs已经为__BOOT_CS.这样可以跳到in_pm32
		.word	__BOOT_CS		# segment 代码段选择子!!!!!!!!!!!其实在这里就隐式的设置了代码段

就设置各个段选择子.所有段寄存器(ds、es、fs、gs、ss)都为设置为_BOOT_DS选择子.

!!!!!!!!!!1注意一旦进入保护模式,就开始以罗辑地址寻址了.即要对给定的地址首先进行段式管理转换,再进行页式管理转换.

跳入保护模式代码jmpl *%eax (这里eax值为0x100000),由于代码段基址为0,所以罗辑地址(段内偏移量)等于线性地址,再由于没有分页,所以线性地址就是物理地址.(请注意上面的内存分布).这里的0x100000为arch/x86/boot/compressed/head_32.S中的startup_32(),用于解压剩余的内核.






###第二次进入保护模式(第二次设置gdtr)

解压完内核后就应该跳入真正的内核,即内核中第二个startup_32().这个时候的整个vmlinux的编译链接地址都是从虚拟地址(线性地址)0xc0000000开始的,有必要重新设置下段寻址,这个是linux内核第二次设置段寻址,称为第二次进入保护模式.这一次设置的原因是在之前的处理过程中，指令地址是从物理地址0x100000开始的，而此时整个vmlinux的编译链接地址是从虚拟地址0xC0000000开始的，所以需要在这里重新设置boot_gdt的位置。

	L88-L107:
		ENTRY(startup_32)
		movl pa(stack_start),%ecx		//栈开始的物理地址
	
		/* test KEEP_SEGMENTS flag to see if the bootloader is asking
			us to not reload segments */
		testb $(1<<6), BP_loadflags(%esi)	//看是否需要设置保护模式环境
		jnz 2f

	/*
	 * Set segments to known values.
	 */
		lgdt pa(boot_gdt_descr)			//设置gdtr
		movl $(__BOOT_DS),%eax			//设置各个段选择子
		movl %eax,%ds
		movl %eax,%es
		movl %eax,%fs
		movl %eax,%gs
		movl %eax,%ss
	2:
		leal -__PAGE_OFFSET(%ecx),%esp		//设置栈顶

GDTR是一个长度为48bit的寄存器，内容为一个32位的基地址和一个16位的段限。其中32位的基址是指GDT在内存中的地址。lgdt后,加载boot_gdt_descr地址的内容,gdtr段限为__BOOT_DS+7,32位基址变为boot_gdt物理地址.

	L737:boot_gdt_descr:
	L738:	.word __BOOT_DS+7			//_BOOT_DS初始化时数据段选择子+7,=0x8f
	L739:	.long boot_gdt - __PAGE_OFFSET		//boot_gdt物理地址


	L757:ENTRY(boot_gdt)
	L758:	.fill GDT_ENTRY_BOOT_CS,8,0		//GDT_ENTRY_BOOT_CS=2
	L759:	.quad 0x00cf9a000000ffff		/* kernel 4GB code at 0x00000000 */
	L760:	.quad 0x00cf92000000ffff		/* kernel 4GB data at 0x00000000 */

.fill后申请了2个8字节内容为0的空间.L759表示4GB内核代码段描述符内容,起始地址为0x00000000,L760为4GB内核数据段描述符内容,起始地址为0x00000000.处于初始化阶段,不存在用户数据段和代码段.

!!!!!!!!!!!!!!!内核运行到这个时候,所有段基址都是0x00000000开始,而内核链接的线性地址都是从虚拟地址0xc0000000,但是这个时候还没有开启分页,那如果要访问一个变量应该怎么寻址呢?其实仅仅使用pa和va就完成了罗辑地址和物理地址的互换.

	#define pa(X) ((X)-__PAGE_OFFSET)
	#define va(X) ((X)+__PAGE_OFFSET)
	__PAGE_OFFSET=0xC0000000（3G,3G-4G为内核空间,32bit(罗辑地址寻址)）
	
	例如刚刚的:
	lgdt pa(boot_gdt_descr)			//设置gdtr


###开启第一次分页

不过虽然有pa和va大法,但是依然不是长久之计,当务之急是开启分页,在内核编译链接时,就已经存在了一张全局目录:

	L662:ENTRY(initial_page_table)
	L663	.fill 1024,4,0	//填充一个页面(4k)的空间

在第一次开启分页时就把这张表作为全局页=目录,将其地址给cr3寄存器开启分页的.

	movl $pa(initial_page_table), %eax
	movl %eax,%cr3		/* set the page table pointer.. */
	movl $CR0_STATE,%eax
	movl %eax,%cr0		/* ..and set paging (PG) bit */

那这张全局目录又是如何初始化,各个页表、表项又是怎么初始化的呢?在链接vmlinux时,有一个叫做BRK段,其开始地址为__brk_base.这个段的作用是保留给用户通过brk()系统调用向内核申请内存空间用的.这里我们先不管它.现在内核需要分配页表空间,应该从哪里开始呢?就从__brk_base分配.那么就需要把__brk_base的物理地址给initial_page_table的第0项还有第767项,分配时同时从第0和第767开始分配,至于为什么是767项,下面会解释.

那么从__brk_base开始的第一个页面就变成第一个页表,第二个页面就变成第二个页表....有多少个页表取决于内核_end的地址.总之要将整个内核都完成从物理地址到虚拟地址的映射.完成后,全局目录和页表的情况是这样的:

![img](/images/memory/pgtpte.png)


这里很奇怪,第0个页表的第0项为什么是0x003,而不是0x0呢?因为内存是以4k对齐了,所以地址表项中存的地址低12位是不表示地址的,这里用作各种标志位.不仅是页表中有这种情况,全局目录中每项页不是存的_brk_base的物理地址,比如第0项存的是_brk_base+0x67,0x67也作为标志位.

PTE_IDENT_ATTR常量,可见定义arch/x86/include/asm/pgtable_types.h:
	#define PTE_IDENT_ATTR  0x003		/* PRESENT+RW */
	#define PDE_IDENT_ATTR  0x067		/PRESENT+RW+USER+DIRTY+ACCESSED */
	#define PGD_IDENT_ATTR 0x001		/* PRESENT (no other attributes) */
	PRESENT=1 页没被交换出内存.PRESENT=0 页被交换出内存,访问内存会产生缺页中断

还有就是刚刚留下的问题,就是为什么要在全局页表的第767项同时分配,原因是这样的:第一次启动分页时目的时将整个内核的物理地址空间映射到虚拟地址空间.而内核在编译链接vmlinux时是从线性地址0xc0000000开始的,解压时是先将vmlinux拷贝到0x1000000以后的内存空间的,然后将它解压到拷贝前的内核镜像地址(0x100000以后).那么通过逻辑地址寻址时0xc0000000线性地址以后的地址需要通过分页映射到物理地址0x00000000开始的空间.0xc00000000>>20=0xc00 0xc00/4=768.所以在分配页表时需要从全局目录表第0和第767项同时开始.

这些工作都完成后,就完成了将物理地址0x00000000到内核_end内存空间映射到线性地址0x00000000开始和0xc0000000开始的内存空间. 这样的话,用逻辑地址0x00000000或者0xc0000000类似的地址都能访问到物理地址0x00000000开始的空间.




###第三次开启保护模式(第三次设置gdtr)

因为开启了分页所以需要设置一次gdtr.Linux x86 的分段管理是通过 GDTR 来实现的,那么现在就来总结一下 Linux 启动以来到现在,共设置了几次 GDTR:
<ul>
<li>1. 第一次还是 cpu 处于实模式的时候,运行 arch\x86\boot\pm.c 下 setup_gdt()函数的代码。该函数,设置了两个 GDT 项,一个是代码段可读/执行的,另一个是数据段可读写的,都是从 0-4G 直接映射到 0-4G,也就是虚拟地址和线性地址相等。</li>
<li>2. 第二次是在内核解压缩以后,用解压缩后的内核代码 arch\x86\kernel\head_32.S 再次对gdt 进行设置,这一次的设置效果和上一次是一样的。</li>
<li>3. 第三次同样是在 arch\x86\kernel\head_32.S 中,只不过是在开启了页面寻址之后,通过分页寻址得到编译好的全局描述符表 gdt 的地址。这一次效果就跟前两次不一样了,为内核最终使用的全局描述符表,同时也设置了 IDT。</li>
</ul>



##文明世界---setup_arch()



###第二次设置分页

在start_arch()中会再次设置一次cr3:

	 873     /*
	 874      * copy kernel address range established so far and switch
	 875      * to the proper swapper page table
	 876      */
	 877     clone_pgd_range(swapper_pg_dir     + KERNEL_PGD_BOUNDARY,              
	 878             initial_page_table + KERNEL_PGD_BOUNDARY,
	 879             KERNEL_PGD_PTRS);
	 880     
	 881     load_cr3(swapper_pg_dir);

在上面,我们初始化了initial_page_table作为全局页目录表.这里把它复制给swapper_pg_dir,在这以后,swapper_pg_dir就一直当做全局目录表使用了....随后设置cr3,弃用以前的initial_page_table.

	定义在:arch/x86/kernel/head_32.S 
	659 initial_pg_pmd:
	660     .fill 1024*KPMDS,4,0
	661 #else  
	662 ENTRY(initial_page_table)
	663     .fill 1024,4,0
	664 #endif 
	665 initial_pg_fixmap:
	666     .fill 1024,4,0
	667 ENTRY(empty_zero_page)
	668     .fill 4096,1,0
	669 ENTRY(swapper_pg_dir)
	670     .fill 1024,4,0


###真正的内存管理

到现在为止,linux内核以上面状态进行了一些列工作(此处略过好多....)....终于来到第一个真正的内核管理函数:setup_memory_map()
