<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         BeiYuu
    -->
    <meta charset="utf-8" />
    <title>Linux/Unix系统编程 | maxwellxxx's Blog</title>
    <meta name="author" content="maxwellxxx" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="maxwellxxx's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">maxwellxxx</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/u/1863312387" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/Linux-Unix" title="Linux/Unix系统编程">Linux/Unix系统编程</a></h1>
        <p class="entry-date">2014-12-02</p>
        <p>更新于：2014-12-07
开始各种填坑，不过决定以后要为每本书都开个坑，以前的书也要开个小坑………总之这个博客就是个大月亮！！！
<img src="/images/manual/moon.jpg" alt="moon" />
不过这篇真的是个正经的存在，我会乱讲？？！！</p>

<p>来吧……</p>

<p>由于这本是手册……所以只是讲关于各个系统调用和一些标准库函数的使用方法和不为人知的注意事项。涉及一些分析总结的话，恩……又来一个坑。</p>

<h2>文件I/O:通用I/O模型</h2>

<h3>打开一个文件open()(系统调用)</h3>

<pre><code>#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
int open(const char *pathname,int flags,.../*mode_t mode*/)
    return fd-SUC，-1-err set errno
</code></pre>

<p>要打开的文件有参数pathname来标识。如果pathname是一符号链接，会对其进行解引用。
flags位为掩码，用于指定文件的访问模式：</p>

<pre><code>O_RDONLY   只读 --、
O_WRONLY   只写 --|不能同时使用
O_RDWR     读写 --/

O_CLOEXEC  设置close-on-exec
O_CREAT    不存在则创建
O_DIRECT   无缓冲I/O
O_DIRECTORY如果pathname不是目录,则失败
O_EXCL     结合O_CREAT使用,专门用于创建文件
O_LARGEFILE在32位系统中打开大文件
O_NOATIME  调用read,不修改文件访问时间
O_NOCTTY   不然pathname成为控制终端
O_NOFOLLOW 对符号链接不做解引
O_TRUNC    截断已有文件,使其长度为0

0_APPEND   总在文件尾部追加数据
O_ASYNC    当I/O操作可行时,产生signal通知进程
O_DSYNC    同步I/O数据完整性
O_NONBLOCK 以非阻塞方式打开
O_SYNC     以同步方式写入
</code></pre>

<ul>    
    <li>前三个为访问模式，不能同时使用。调用fcntl()的F_GETFL能够查看当前访问模式。</li>
    <li>第二部分为文件创建标志,不能检索不能修改.</li>
    <li>第三部分状态标志位,可用fcntl()修改和检索</li>
</ul>


<p>其中O_CLOEXEC是为了防止多线程程序执行fcntl()时引发竞争场景,可能会使文件描述符泄露给不安全的程序.而O_CREATE和O_EXEL同时使用可以确保文件肯定是由当前进程创建的.</p>

<p>mode参数如果没有指定O_CREATE,可以省略.
mode_t
稍后补</p>

<p>出错处理
稍后补</p>

<h3>创建件一个文件create()(系统调用)</h3>

<pre><code>#include &lt;fcntl.h&gt;
int creat(const char *pathname,mode_t mode);
return fd-SUC,-1-ERR
</code></pre>

<p>因为早期的UNIX中open中只有两个参数,无法创建文件,这个则用了专门创建文件.</p>

<h3>读取文件内容read()(系统调用)</h3>

<pre><code>#include&lt;unistd.h&gt;
ssize_t read(int fd,void *buffer,size_t count);
return number of bytes read,0-EOF,-1-ERR
</code></pre>

<p>可能返回值小于count,可能是当前读取的位置靠近文件尾部.或者读取管道,FIFO,socket或者终端是,读到\n时read也会结束.</p>

<h3>数据写入文件write()(系统调用)</h3>

<pre><code>#include&lt;unistd.h&gt;
ssize_t write(int fd,void *buffer,size_t count);
return number of written,-1-err
</code></pre>

<p>返回值可能小于count,成为"部分写",造成的原因是磁盘已满,或者进程资源对文件大小的限制.</p>

<h3>关闭文件close()(系统调用)</h3>

<pre><code>#include&lt;unistd.h&gt;
int close(int fd);
return 0-SUC,-1-ERR
</code></pre>

<p>有必要检查错误,防止关闭失败,耗尽文件描述符资源.</p>

<h3>改变文件偏移量了lseek()(系统调用)</h3>

<pre><code>#include&lt;unistd.h&gt;
off_t lseek(int fd,off_t offset,int whence);
return new offset-SUC,-1-ERR
</code></pre>

<p>参数offset指定了以字节为单位的数值(off_t为有符号数).</p>

<p>whence参数指定由哪个基点来解释offset</p>

<ul>
    <li>SEEK_SET  将基点设置为文件起点.offset必须为正</li>
    <li>SEED_CUR  相对于当前的偏移,将偏移量调整offset个字节.offset可为负数</li>
    <li>SEEK_END  将文件偏移设置为起始于文件尾部后的offset个字节,此时,offset参数要从文件最后一个字节的下一个字节算起!offset可为负数</li>
</ul>


<p>可以这样获取当前offset</p>

<pre><code>curr=lseek(fd,0,SEEK_SET);
</code></pre>

<p>另外此函数不能用于管道,FIFO,socket或者终端!!!!!!</p>

<h3>通用模型以外的I/O操作ioctl()(系统调用)</h3>

<pre><code>#include&lt;sys/ioctl.h&gt;
int ioctl(int fd,int request,.../*argp*/);
return depends on request-SUC,-1-ERR
</code></pre>

<h2>深入文件I/O</h2>

<h3>文件控制操作fcntl()(系统调用)</h3>

<pre><code>#include&lt;fcntl.h&gt;
int fcntl(int fd,int cmd,...);
return depends on request-SUC,-1-ERR
</code></pre>

<p>cmd参数支持的操作很多,这里逐步加吧,后三个省略号根据cmd来看,可以有可以没有.</p>

<pre><code>cmd:
F_GETFL   获取访问访问模式和状态标志
F_SETFL   修改文件某些状态标志,允许修改的有O_APPEND,O_NONBLOCK,O_NOATIME,O_ASYNC,O_DIRECT.修改其他会被系统忽略
F_DUPFD   复制文件操作符。
</code></pre>

<p>F_GETFL返回的flags如果用于判断访问模式会有些复杂,原因是那三个常量不与状态标志位中的单个比特位对应,要用掩码O_ACCMODE与返回的flags相与.示例:</p>

<pre><code>int accessMode=flags&amp;O_ACCMODE
if(accessMode==O_WRONLY||accessMode==O_RDWR)
    printf("writable!");
</code></pre>

<p>使用fcntl()修改文件状态标志,尤其适合如下场景</p>

<ul>
    <li>文件不是由调用程序打开的,不能通过open来控制文件状态标志.比如文件是3个标准输入输出描述符中的一个</li>
    <li>文件是通过open以外的系统调用打开的,比如pipe(),socket()</li>
</ul>


<p>在修改时,应该先获取当前flags然后修改对应的比特位,然后在set.</p>

<h3>复制文件描述符(系统调用)</h3>

<pre><code>#include &lt;unistd.h&gt;
int dup(int oldfd);
retrun new fd -SUC,-1-ERR
</code></pre>

<p>该调用复制一个已经打开的fd,返回一个新的fd,但是他们两个指向同一个文件句柄.</p>

<pre><code>#include&lt;unistd.h&gt;
int dup2(int oldfd,int newfd);
retrun new fd -SUC,-1-ERR
</code></pre>

<p>这个函数基本同上个函数，但是会返回个一由newfd指定的文件描述符编号，如果指定的描述符已经打开，那此函数会先隐式的将它关闭……并且忽略关闭时的错误。更好的编码方式是在调用此函数前先显示调用close将newfd关闭。</p>

<pre><code>//另外一种灵活的方法复制文件描述符
newfd=fcntl(oldfd,F_DUPFD,startfd);
/*为oldfd创建副本，并且分配大于等于startfd且未使用的最小newfd。
*/
</code></pre>

<p>复制的newfd与oldfd享有同一个打开文件句柄，文件偏移量，状态标志。然而newfd拥有自己一套文件描述符标志，且其close-on-exec处于关闭。</p>

<p>关于文件描述符号的分配等问题，将另外讨论。</p>

<pre><code>#include &lt;unistd.h&gt;
int dup3(int oldfd,int newfd,int flags);
retrun new fd -SUC,-1-ERR
</code></pre>

<p>dup3完成的工作与dup2相同，但是可以指定flags，但是只支持O_CLOEXEC。这将促使内核为新的文件描述符设置close-on-exec位。</p>

<h3>在文件特定偏移量处I/O：pread()和pwrite()(系统调用)</h3>

<pre><code>#include &lt;unistd.h&gt;
ssize_t pread(int fd,void *buf,size_t count,off_t offset);
    return number of bytes read,0-EOF,-1-ERR
ssize_t pwrite(int fd,const void *buf,size_t count,off_t offset);
    return number of bytes written,-1-ERR
</code></pre>

<p>我们知道进程下所有线程共用一个文件描述符表，这两个函数可以在多线程对同一个文件I/O时避免受其他线程修改offset影响。</p>

<ul>
    <li>这两个函数会在指定的offset偏移处进行操作，而且不改变当前偏移量。</li>
</ul>


<h3>分散输入和集中输出readv()&amp;writev()(系统调用)</h3>

<pre><code>#include &lt;sys/uio.h&gt;
ssize_t readv(int fd,const strcut iovec *iov,int iovcnt);
    return number of bytes read,0-EOF,-1-ERR
ssize_t writev(int fd,const strcut iovec *iov,int iovcnt);
    return number of bytes written,-1-ERR
</code></pre>

<p>这两个系统调用用于一次传输多个缓冲区的数据。每组iov定义了一组用于传输的数据。iovcnt则指定了iov的个数。</p>

<pre><code>struct iovec
{
    void *iov_base;     //start addr of buffer
    size_t iov_len;     //number of bytes to transfer to/from buffer
}
</code></pre>

<p>readv()实现了从fd读取一片连续的数据，然后将其分散放置在iov指定区域里。这一动作从iov[0]开始一次填满每个缓冲。writev()则实现相反的动作</p>

<ul>
    <li>这两个函数是atom的，即所与操作一个次性完成。即不受其他线程改变偏移量影响。</li>
    <li>这两个函数会改变文件偏移量。</li>
</ul>


<h3>截断文件truncate()&amp;ftruncate()(系统调用)</h3>

<pre><code>#include &lt;unistd.h&gt;
int truncate(const char *pathname,off_t length);
int ftruncae(int fd,off_t length);
</code></pre>

<p>若文件当前长度大于参数lengtg，调用丢弃超出部分，如果小于length则在文件末添加一些列空字节或形成文件空洞。</p>

<h3>创建临时文件mkstemp()(库函数)</h3>

<pre><code>#include &lt;stdlib.h&gt;
int mkstemp(char *template)
    return fd-SUC,-1-ERR
</code></pre>

<p>参数为路径名形式，但是最后六个字符一定要是XXXXXX，因为这六个字符会被替换成。</p>

<ul>
    <li>因为会对传入的参数进行修改，所以必须为字符数组，而非字符串常量。</li>
    <li>文件拥有者对建立的文件有读写权限（使用了O_EXCL），其他用户没有权限。</li>
    <li>在调用成功后，应该立即使用unlink(template)，以便在关闭后自动删除临时文件。</li>
</ul>


<pre><code>#include&lt;stdio.h&gt;
FILE *tmpfile(void);
    return file pointer-SUC,-1-ERR
</code></pre>

<p>创建一个名称唯一的临时文件，并使用O_EXCL，防止冲突。返回文件流供stdio库函数使用。文件流关闭后将自动删除文件。即隐式调用unlink()。</p>

<h2>进程</h2>

<h3>获取(父)进程号getpid()&amp;getppid()(系统调用)</h3>

<pre><code>#include &lt;unistd.h&gt;
pid_t getpid(void);
pid_t getppid(void);
    always SUC
</code></pre>

<h3>访问和修改环境变量(库函数)</h3>

<pre><code>#include &lt;stdlib.h&gt;
char *getenv(const char *name);
    return pointer to value,NULL-no such variable
</code></pre>

<p>从环境变量里检索单个之，传入环境变量名，返回相应的字符串指针。（返回name=value 的value部分。）</p>

<ul>
    <li>也可以在程序中使用全局变量的形式访问 extern char **environ</li>
    <li>环境变量的修改会被以后创建的子进程可见，即环境变量也是一种进程乃至程序通讯方法。</li>
</ul>


<pre><code>#include &lt;stdlib.h&gt;
int putenv(char *string);
    return 0-SUC,nonzero-ERR
</code></pre>

<p>string指向name=value字符串，由于只是将environ中一个元素指向string，所以string不应该是在栈中分配的字符串，而且以后修改string也将影响环境变量。</p>

<pre><code>#iclude &lt;stdlib.h&gt;
int setenv(const char *name,const char *value,int overwrite);
    return 0-SUC,-1-ERR
</code></pre>

<p>函数为形如name=value的字符串分配一块内存缓冲，并将name和value所指的字符串复制到缓冲。如果name已经存在，且overwrite为0則不改变，如果为1则改变。</p>

<ul>
    <li>name中不应该有‘=’号。</li>
</ul>


<pre><code>#include &lt;stdlib.h&gt;
int unsetenv(const char *name);
    return 0-SUC,-1-ERR
</code></pre>

<p>移除name标识的环境变量。</p>

<p>当为了以安全方式执行set-user-ID程序时，可能需要清空环境变量以重建。这是可以使用将全局变量environ设为NULL。</p>

<pre><code>extern char **environ;
environ=NULL:
</code></pre>

<p>也可以使用以下函数</p>

<pre><code>#define _BSD_SOURCE
#include &lt;stdlib.h&gt;
int clearenv(void);
    return 0-SUC,-1-ERR
</code></pre>

<ul>
    <li>使用setenv()和clearenv()可能导致内存泄露，当使用setenv()时会分配内存，clearenv()时则不知道已经分配内存，所以不会释放，从而导致内存泄露。所以一般都在程序开始执行clearenv()，用于移除从父进程继承的环境变量。</li>
</ul>


<h3>执行非局部跳转命令setjmp()&amp;longjmp()(库函数)</h3>

<ul>
    <li>“非局部”是指跳转的目标为当前执行函数之外的某个位置。</li>
</ul>


<p>C语言中的goto语句存在一个限制，即不能从当前的函数跳转到另一个函数。但是考虑到在错误处理时可能出现这样的场景：</p>

<ul>
    <li>在一个深层嵌套的调用的函数中发生了错误，需要放弃当前任务，从多层函数调用中返回，并在更层级的函数中继续执行。甚至是在main()函数中。</li>
</ul>


<p>那么可以使用如下的函数：</p>

<pre><code>#include &lt;setjmp.h&gt;
int setjmp(jmp_buf env);
    return 0-initial call,nonzero-return via longjmp()
void longjmp(jmp_buf env,int val);
</code></pre>

<p>setjmp()的调用为后续的longjmp()执行的跳转确立了跳转目标。该目标为程序发起setjmp()调用的位置。通过查看setjmp()的返回值，可以知道是第一次调用setjmp()返回，还是后续调用了longjmp()的伪返回。初始返回值为0,后续“伪”返回值为longjmp中val参数指定的任意值。根据返回值的不同，可以区分出跳转到同一目标的不同起跳位置。</p>

<ul>
    <li>longjmp的val参数如果指定为0,实际执行时会替换成1。</li>
</ul>


<p>而参数env为成功跳转的粘合剂，setjmp()函数把当前进程环境的各种信息保存到env中，调用longjmp时必须制定相同的env，一次来执行“伪”返回。由于两次调用在不同的函数（不然可以使用goto），所以env最好为全局变量。</p>

<ul>
    <li>env除了保存了进程信息外，还保存了ip，和esp寄存器。其实是通过这两个值来实现返回的。</li>
</ul>


<p>不要滥用！！！！！！！
还有要注意编译器优化的问题带啦的代码重组。</p>

<h2>内存分配</h2>

<h3>分配堆上内存</h3>

<p>所谓的堆，其实就是一段长度可变的连续虚拟内存。通常始于进程未初始化数据段末尾。随着内存的分配和释放增减，通常将堆的内存边界成为“program break”。</p>

<h3>调整program break brk()&amp;sbrk()(系统调用)</h3>

<pre><code>#include &lt;unistd.h&gt;
int brk(void *end_data_segment);
    return 0-SUC,-1-ERR
void *sbrk(intptr_t increment);
    return previous pb-SUC,-1-ERR
</code></pre>

<p>brk()会将pk设为end_data_segment指定位置，由于虚拟内存按页分配，所以会四舍五人到下一个内存边界。</p>

<p>sbrk()会将pk在原有的基础上增加increment。sbrk()会返回前一个pk地址，那么如果pk增加，返回的是增加的内存的起始地址。</p>

<pre><code>sbrk(0)//返回当前的pk，而不做改变。
</code></pre>

<h3>在堆上分配内存malloc()&amp;free()(库函数)</h3>

<pre><code>#include &lt;stdlib.h&gt;
void *malloc(size_t size);
    return pointer to allocated memory -SUC,NULL-ERR
void free(void *ptr);
</code></pre>

<h3>其他堆内存分配方法(库函数)</h3>

<pre><code>#include &lt;stdlib.h&gt;
void *calloc(size_t numitems,size_t size);
    return pointer to allocated memory -SUC,NULL-ERR
</code></pre>

<p>用与给一组相同的对象分配内存，numitems为对象数量，size为每个对象的大小。会将分配的内存初始化为0.</p>

<pre><code>#include &lt;stdlib.h&gt;
void *realloc(void *ptr,size_t size);
    return pointer to allocated memory -SUC,NULL-ERR
</code></pre>

<p>用于调整（通常是增加）一块内存的大小，此内存必须要是由malloc分配。返回调整后的内存地址，与之前的相比，可能位置不同。如果返回NULL则不改动ptr指向的内存。</p>

<ul>
    <li>如果原内存块后空间不足，则分配新内存，并将数据复制到新内存中。</li>
    <li>如果原内存块后能够分配内存，则直接扩展。</li>
</ul>


<h4>分配对齐的内存memalign()&amp;posix_memalign()</h4>

<p>函数分配内存的起始位置要与2的整数u次幂边界对齐。</p>

<pre><code>#include &lt;malloc.h&gt;
void *memalign(size_t boundary,size_t size);
    return pointer to allocated memory -SUC,NULL-ERR
</code></pre>

<p>分配size个字节的内存，起始地址是参数boudary的整数倍，而boudary必须是2的整数次幂。</p>

<pre><code>#include &lt;stdlib.h&gt;
int posix_memalign(void **memptr,size_t alignment,size_t size);
    return 0-SUC,a positive error number-ERR
</code></pre>

<p>已经分配的内存地址有memptr返回。</p>

<h3>在堆栈上分配内存</h3>

<pre><code>#include &lt;alloca.h&gt;
void *alloca(size_t size); 
    return pointer to allocated block of memory
</code></pre>

<p>size指定要在栈上分配的内存大小,通过它分配的内存。</p>

<ul> 
    <li>不能用free来释放，因为跳出栈帧时会自动释放。</li>
    <li>不能在函数的参数列表中使:func(x,alloca(size)</li>
    <li>在信号处理程序中使用longjmp，用alloca更有优势，因为用malloc分配的内存不能有效free,而alloca通过解栈就释放了。</li>
</ul>


<h2>用户和组</h2>

<h3>获取用户和组的信息</h3>

<h4>从密码文件/etc/passpw获取记录getpwnam()&amp;getpwuid()(库函数)</h4>

<pre><code>#include &lt;pwd.h&gt;
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
    return pointer -SUC,NULL-ERR
</code></pre>

<p>为name提供一个登录名，或者为uid提供一个用户ID。返回一个数据结构：</p>

<pre><code>struct passwd
{
    char *pw_name;  //Login name
    char *pw_passwd //Encrypted password
    uid_t pw_uid;   //User ID
    gid_t pw_gid;   //Group ID
    char *pw_gecos; //comment (user information)
    char *pw_dir;   //initial working directory(home)
    char *pw_shell; //Login shell
}
</code></pre>

<p>当没有开启shadow密码的情况下，pw_passwd才会包含有效信息。</p>

<ul>
    <li>注意，这里返回的指针都指向一个静态分配的结构，所以任何一次调用都会改写该数据结构！！！！</li>
    <li>所以这两个函数都是不可以重入的</li>
</ul>


<h4>从组文件/etc/group获取记录getgrnam()&amp;getgrgid()(库函数)</h4>

<pre><code>#include &lt;grp.h&gt;
struct group *getgrnam(const char *name);
struct group *getgrgid(gid_t gid);
    return pointer -SUC,NULL-ERR
</code></pre>

<p>两者通过组名和组ID来返回一个数据结构指针：</p>

<pre><code>struct group
{
    char *gr_name;
    char *gr_passwd;
    gid_t gr_gid;
    char **gr_mem;      //menbers in this group listed in /etc/group
}
</code></pre>

<ul>
    <li>两者返回的指针同样指向一个静态分配的结构，任何一次调用都会改写数据。</li>
    <li>两者不可重入</li>
</ul>


<h4>扫描密码文件和组文件中的所有记录(库函数)</h4>

<p>这里是一组函数配合使用</p>

<pre><code>#include &lt;pwd.h&gt;
struct passwd *getpwent(void);
    return pointer-SUC,NULL or end of stream-ERR
void setpwent(void);
void endpwent(void);
</code></pre>

<p>getpwent()会从密码文件中逐条返回记录，如果出错或到末尾，返回NULL。一经调用就自动打开密码文件，处理结束后需要调用endpwent()关闭。在处理文件中途，可以调用setpwent()返回到文件起始处。</p>

<p>相同的还有从组文件中扫描：</p>

<pre><code>#include &lt;shadow.h&gt;
struct group* getgrent(void);
    return pointer-SUC,NULL or end of stream-ERR
void setgrent(void);
void endgrent();
</code></pre>

<p>同上面一组函数。</p>

<ul>
    <li>注意，这两组返回的指向数据结构也是静态分配的！！！</li>
    <li>所以，每次调用getpwnam(),getpwuid(),getpwent()其中一个，都会改变数据结构!!group系的函数同理!!</li>
</ul>


<h4>从shadow密码文件中获取记录(库函数)</h4>

<p>下列函数作用基本同上！从shadow返回个别记录或者扫描返回记录。</p>

<pre><code>#include &lt;shadow.h&gt;
struct spwd* getspwnam(const char *name);
    return pointer-SUC,NULL-ERR
strcut spwd* getspent(void);
    return pointer-SUC,NULL or end of stream-ERR
void setspent(void);
void endspent(void);
</code></pre>

<p>类似与上面函数，返回结构体也为静态分配。</p>

<pre><code>strcut spwd
{
    char *sp_namp;  //login name
    char *sp_pwdp;  //encrypted password
    long sp_lstchg; //Time of last password change(days since 1970.1.1)
    long sp_min;    
    long sp_max;
    long sp_warn;
    long sp_inact;
    long sp_expire;
    unsigned long sp_falg;
}
</code></pre>

<ul>
    <li>访问shadow必须为root或者shadow组用户，不然会出权限错误。</li>
</ul>


<h3>密码加密和用户认证(系统调用)</h3>

<p>由于UNIX系统密码采用单向加密，所以无法通过加密过的密码来还原原始密码，所以认证方式是将待验证密码加密于/etc/shadow中的密码进行匹配。加密方法封装在crypt()。</p>

<pre><code>#define _XOPEN_SOURCE
#include &lt;unistd.h&gt;
char *crypt(const char *key,const char *salt);
    return pointer to encrypted password-SUC,-1-ERR
</code></pre>

<p>key为要加密的密码，salt为指向2个字符的字符串，用于搅动DES加密算法（保证安全性）。（S盒变换么……轻喷）。返回加密后的字符串指针。</p>

<ul>
    <li>返回的字符串为静态分配，请注意！</li>
    <li>在返回的字符串中，前两个字符是对salt的拷贝，也就是说，如果要比对shadow中的密码，salt的值就是shadow中密码的前两个字符！</li>
    <li>在linux中如果要使用crypt()需要开启-lcrypt编译选项，以便链接crypt库。</li>
    <li>在完成加密后，应该尽快释放明文密码。</li>
</ul>


<h2>进程凭证</h2>

<p>每个进程都有一套数字用于表示用户的ID（UID）和组ID（GID），有时，也将这些ID称之为进程凭证，具体如下：</p>

<ul>
    <li>实际用户ID（real user ID）和实际组ID（real gourp ID）</li>
    <li>有效用户ID（effective user ID）和有效组ID（effective group ID）</li>
    <li>保存的set-user-ID（saved set-user-ID）和保存的set-group-ID（seved set-group-ID）</li>
    <li>文件系统用户ID（file-system User ID）和文件系统组ID（file-system Group ID）（linux 专有）</li>
    <li>辅助组ID</li>
</ul>


<p>在/proc/PID/status文件中会按照实际、有效、保存、文件系统的顺序将这些ID列出来。</p>

<p>这里解释各个的含义：</p>

<ul>
    <li>实际ID:即运行当前程序的用户ID以及用户所在的组ID</li>
    <li>有效ID:即当前运行程序实际拥有哪个用户ID和组ID的权限</li>
    <li>set-user-ID程序会将进程的有效ID置成可执行文件的属主用户ID，set-group-id同理。</li>
    <li>保存的set-user-ID和保存的set-group-id在程序初始化时有有效id复制过来，无论当前程序是否是一个set-user（group）-id程序。</li>
    <li>文件系统ID基本等同于相应的有效ID</li>
    <li>辅助组ID一般都从父进程继承。</li>
</ul>


<p>这里需要注意的是：</p>

<ul>
    <li>在Linux中，set-user-id和set-group-id权限位对shell脚本不适用，理由见详细分析。</li>
</ul>


<p>可用下列命令为可执行程序加上set-user-id和set-group-id权限位：</p>

<pre><code>$ su
# ls -l example
-rwxr-xr-x  1 root      root
#chmod u+s example       //加上set-user-id权限位
# ls -l example
-rwsr-xr-x  1 root      root
#chmod g+x example   //加上set-group-id权限位
# ls -l example
-rwsr-sr-x  1 root      root
</code></pre>

<p>其他的另见详细分析。</p>

<h3>获取和修改进程凭证</h3>

<p>TIPS：Linux将超级用户划分成各种不同的能力，其中包括：</p>

<ul>
    <li>CAP_SETUID能力允许进程任意修改其用户ID。</li>
    <li>CAP_SETGID能力允许进程任意修改起组ID</li>
</ul>


<h4>获取和修改实际、有效和保存设置的标识（系统调用）</h4>

<p>获取实际和有效ID</p>

<pre><code>#include &lt;unistd.h&gt;
uid_t getuid(void);
    return real user ID of calling process
gid_t getgid(void);
    return real group ID of calling process
uid_t geteuid(void);
    return effective user id of calling process
gid_t getegid(void);
    return effective group id of calling process
</code></pre>

<p>修改有效ID</p>

<pre><code>#include &lt;unistd.h&gt;
int setuid(uid_t uid);
int setgid(gid_t gid);
    return 0-SUC,-1-ERR
</code></pre>

<p>setuid()会根据给出的uid参数值来修改调用进程的有效用户ID，也可能会修改实际用户ID和保存set-user-id。系统调用setgid()实现了相似的功能。</p>

<p>另外两个函数遵守如下规则</p>

<ul>
    <li>规则1：当非特权进程调用时，仅能修改进程的有效ID，而且仅能将有效ID修改成相应的实际用户ID或者保存的set-user-id。那么这就意味着，对于非特权用户只有执行一个set-user-id程序是，函数才有实际的意义。</li>
    <li>规则2：当特权级进程以一个非0的参数调用函数时，其实际、有效、保存ID都会被置为指定的值，而且这一操作是单项的，一旦特权级进程以此方式修改了ID，那么所有的特权全部丢失，且不可逆。如果要避免这些情况，可使用seteuid(),setegid()。</li>
</ul>


<p>对于规则2：如果是调用setgid()不会造成特权丢失，因为特权有userid决定。</p>

<p>对一个特权进程来说，永久放弃特权做法如下：</p>

<pre><code>if(setuid(getuid())==-1)
    errExit(setuid);
</code></pre>

<p>进程能够使用seteuid()来修改其有效用户ID，或者setegid()来修改有效组ID：</p>

<pre><code>#include &lt;unistd.h&gt;
int seteuid(uid_t uid);
int setegid(gid_t gid);
    return 0-SUC,-1-ERR
</code></pre>

<p>这两个函数遵循如下规则：</p>

<ul>
    <li>规则1：当非特权进程调用时，仅能将有效ID修改成实际或者保存的ID。</li>
    <li>规则2：当特权级进程调用时，可将有效ID（仅仅修改有效ID）修改为任意值。如果一个特权进程将有效ID修改成非0则会丢失特权，但是可以通过规则1来恢复特权。</li>
</ul>


<p>例，特权进程放弃进程，并恢复特权：</p>

<pre><code>euid=geteuid();         //保存euid用以恢复
if(seteuid(getuid())==-1)   //丧失特权
    errExit(seteuid);
if(seteuid(euid))       //恢复特权
    errExit(seteuid);
</code></pre>

<h4>修改实际ID和有效ID</h4>

<pre><code>#include &lt;unistd.h&gt;
int setreuid(uid_t ruid,uid_t euid)
int setregid(gid_t rgid,gid_t egid)
    return 0-SUC,-1-ERR
</code></pre>

<p>两个函数第一个参数指定新的实际ID，第二个参数指定新的有效ID，如果有一个不想修改，置为-1即可。</p>

<p>两个函数也遵守几个规则：</p>

<ul>
    <li>规则1：当非特权进程调用时，仅能将实际Id设为当前实际ID或者有效id，且能将有效ID设为当前实际ID、有效ID或者保存ID。</li>
    <li>规则2：特权级进程能设置实际ID和有效ID为任意值。</li>
</ul>


<p>规则3：不管进程特权与否，只要满足下列条件之一，就将保存set-user-id设置为新的有效用户ID</p>

<ul>
    <li>ruid不为-1（即设置实际ID，即便是设置为当前值）</li>
    <li>对于有效ID所设置的值不同于系统调用之前的实际用户ID</li>
</ul>


<h4>获取实际，有效和保存设置ID（Linux下非标准系统调用）</h4>

<pre><code>#define _GNU_SOURCE
#include &lt;unistd.h&gt;

int getresuid(uid_t *ruid,uid_t *euid,uid_t *suid);
int getresgid(gid_t *rgid,gid_t *egid,gid_t *sgid);
</code></pre>

<h4>修改实际，有效和保存设置ID（Linux下非标准系统调用）</h4>

<p>太懒了，反正各种都系统都鲜有支持，所以这里不罗列。</p>

<h3>获取和修改文件系统ID（系统调用）</h3>

<p>太懒了，反正Linux这两个功能已经没有用了，所以忽略！</p>

<h3>总结</h3>

<p>这里差张表！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</p>

<h2>时间</h2>

<p>程序一半会关注两种时间：</p>

<ul>
    <li>真实时间：度量这一时间的起点有二：一为某个标准点；二为进程生命周期内的某个固定点（通常为程序启动时）。前者为"日历时间"适用于对数据库记录或者文件打上时间戳的程序，后者为“流逝时间”主要针对于需要周期性操作或者定期从外部输入设备进行度量的程序。</li>
    <li>进程时间：一个进程使用的CPU时间总量，适用于对程序、算法性能的检测和优化。</li>
</ul>


<h3>日历时间</h3>

    </div>

    <div class="sidenav">
        <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1863312387&verifier=996dff3a&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/yougan">我是喷子</a></li>
        
            <li><a href="/newstory">新的故事</a></li>
        
        </ul>

        <h2>My Manual</h2>
        <ul class="artical-list">
        
            <li><a href="/Linux-Unix">Linux/Unix系统编程</a></li>
        
        </ul>

        <h2>Project</h2>
        <ul class="artical-list">
        
            <li><a href="/tinyos-ana">Tinyos概要分析</a></li>
        
            <li><a href="/tinyos">Ubuntu 下Tinyos开发环境的搭建</a></li>
        
            <li><a href="/github-pages">使用Github Pages建独立博客</a></li>
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>
</body>
</html>
